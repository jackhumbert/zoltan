use std::collections::HashMap;
use std::fmt::Display;
use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};

use itertools::Itertools;
use ustr::Ustr;
use enum_as_inner::EnumAsInner;

use crate::error::{Result, SymbolError};
use crate::symbols::FunctionSymbol;
use crate::types::{Type, TypeInfo, FunctionEnum};


#[derive(Debug, Clone, PartialEq, EnumAsInner)]
pub enum SymbolEntry {
    Found(FunctionSymbol),
    NotFound(SymbolError)
}

impl SymbolEntry {
    pub fn full_name(&self) -> &str {
        match self {
            Self::Found(func) => func.full_name(),
            Self::NotFound(err) => err.full_name().into()
        }
    }
}

const HEADER: &str = "\
// This file has been generated by zoltan (https://github.com/jac3km4/zoltan)

#define ZOLTAN_STRINGISE(N) #N
#define ZOLTAN_EXPAND_THEN_STRINGISE(N) ZOLTAN_STRINGISE(N)
#define __LINE_STR__ ZOLTAN_EXPAND_THEN_STRINGISE(__LINE__)
";

pub fn format_name_for_addr(s: &str) -> String {
    // if s.context().is_empty() {
    //     s.name().replace("~", "_")
    // } else {
    //     format!("{}_{}", s.context().replace("RED4ext::", "").replace("::", ""), s.func_name().replace("~", "_"))
    // }

    let mut v: Vec<&str> = s.split("::").collect();
    let name = v[v.len()-1].replace("~", "_");
    v.remove(v.len()-1);
    if v[0].eq("RED4ext") {
        v.remove(0);
    }
    let context = v.join("");
    if context.is_empty() {
        name.into()
    } else {
        format!("{}_{}", context, name)
    }
}

pub fn write_c_header<W: Write>(mut output: W, symbols: &[FunctionSymbol], errors: &[SymbolError], safe: bool) -> Result<()> {
    writeln!(output, "{}", HEADER)?;
    let mut all_symbols: Vec<SymbolEntry> = vec![];
    symbols.into_iter().for_each(|f| all_symbols.push(SymbolEntry::Found(f.to_owned())));
    errors.into_iter().for_each(|f| all_symbols.push(SymbolEntry::NotFound(f.to_owned())));

    all_symbols.sort_by(|a, b| a.full_name().partial_cmp(b.full_name()).unwrap());
    all_symbols.dedup_by(|a, b| a.full_name().eq(b.full_name()));
    // sorted.sort_by(|a, b| a.rva().partial_cmp(&b.rva()).unwrap());
    for entry in all_symbols {
        match entry {
            SymbolEntry::Found(symbol) => {
                let addr_name = format_name_for_addr(symbol.full_name());
                if safe {
                    writeln!(
                        output,
                        "#ifndef {}_Addr\n#define {}_Addr 0x{:X}\n#endif",
                        addr_name,
                        addr_name,
                        symbol.rva()
                    )?;
                } else {
                    writeln!(
                        output,
                        "#define {}_Addr 0x{:X}",
                        addr_name,
                        symbol.rva()
                    )?;
                }
            },
            SymbolEntry::NotFound(error) => {
                let addr_name = format_name_for_addr(error.full_name().into());
                writeln!(
                    output,
                    "#define {}_Addr 0 {}",
                    addr_name,
                    format!(r#"_Pragma("message(__FILE__ \"(\" __LINE_STR__ \") : Warning: {}_Addr is 0 - Zoltan found {}\")")"#,
                        addr_name,
                        error.to_string()
                    )
                )?;
            }
        }
    }

    Ok(())
}

pub fn write_c_definition<W: Write>(mut output: W, symbols: &[FunctionSymbol], errors: &[SymbolError]) -> Result<()> {
    writeln!(output, "#pragma once")?;
    write_c_header(output.by_ref(), symbols, errors, true)?;
    writeln!(output, "\n#include <RED4ext/RED4ext.hpp>")?;
    writeln!(output, "#include <RED4ext/Relocation.hpp>")?;
    // writeln!(output, "#ifdef RED4EXT_STATIC_LIB")?;
    let mut sorted = symbols.to_vec();
    sorted.sort_by(|a, b| a.name().partial_cmp(b.name()).unwrap());
    sorted.dedup_by(|a, b| a.name().eq(b.name()));
    // sorted.sort_by(|a, b| a.rva().partial_cmp(&b.rva()).unwrap());
    // let map: HashMap<Ustr, &FunctionSymbol> = sorted.iter().filter(|s| s.file_name().is_some()).map(|s| (s.file_name().unwrap(), s)).into_iter().collect();
    let map = sorted.iter().filter(|s| s.file_name().is_some()).group_by(|s| s.file_name().unwrap());
    for (file_name, _group) in map.into_iter() {
        let file_path = Path::new(file_name.as_ref());
        if let Some(_) = file_name.find("RED4ext/") {
            let prefix = file_name.rsplit_once("RED4ext/").unwrap().0;
            writeln!(output, "#include <{}>", file_path.strip_prefix(prefix).unwrap().as_os_str().to_str().unwrap().to_string())?;
        }
    }
    // writeln!(output, "#endif")?;
    writeln!(output, "")?;
    
    for symbol in sorted {
        if !symbol.needs_impl() {
            continue
        }
        match symbol.function_type() {
            Type::Function(func) => {
                let addr_name = format_name_for_addr(symbol.full_name());
                let args;
                let header;
                match func.func_type {
                    FunctionEnum::Virtual => continue,
                    FunctionEnum::Method => {
                        header = func.params.iter().enumerate().filter(|(i, _f)| *i != 0).map(|(i, f)| f.name_with_id(format!("a{}", i).as_str())).join(", ");
                        args = func.params.iter().enumerate().map(|(i, _f)| {
                        if i == 0 { 
                            "this".into()
                        } else { 
                            format!("a{}", i)
                        }}).join(", ");
                    },
                    FunctionEnum::Typedef => {
                        header = func.params.iter().enumerate().map(|(i, f)| f.name_with_id(format!("a{}", i).as_str())).join(", ");
                        args = func.params.iter().enumerate().map(|(i, _f)| format!("a{}", i)).join(", ");
                    },
                    FunctionEnum::Static => {
                        header = func.params.iter().enumerate().filter(|(i, _f)| *i != 0).map(|(i, f)| f.name_with_id(format!("a{}", i).as_str())).join(", ");
                        args = func.params.iter().enumerate().filter(|(i, _f)| *i != 0).map(|(i, _f)| format!("a{}", i)).join(", ");
                    },
                }
                writeln!(
                    output,
                    "inline {} {}({}) {{\n    RED4ext::RelocFunc<decltype(&{})> call({}_Addr);\n    return call({});\n}}\n",
                    func.return_type.name(),
                    symbol.full_name(),
                    header,
                    symbol.full_name(),
                    addr_name,
                    args
                )?;
            }
            _ => {

            }
        }
    }
    // for (file_name, group) in map.into_iter() {
    //     let file_path = Path::new(file_name.as_ref());
    //     let mut new_file_path = file_path.to_path_buf();
    //     new_file_path.set_file_name(file_path.file_stem().unwrap().to_os_string().to_str().unwrap().to_owned() + "-inl-gen");
    //     new_file_path.set_extension("hpp");
    //     // let mut file = File::create(new_file_path)?;
    //     // writeln!(file, "{}", HEADER)?;
    //     for symbol in group {
    //         match symbol.function_type() {
    //             Type::Function(func) => {
    //                 let clean_name = symbol.name().replace("RED4ext::", "").replace("::", "_").replace("~", "_");
    //                 let header =  func.params.iter().enumerate().map(|(i, f)| f.name().to_string() + " a" + &i.to_string()).join(", ");
    //                 let mut args =  func.params.iter().enumerate().map(|(i, _f)| format!("a{}", i)).join(", ");
    //                 if func.func_type != FunctionEnum::Static && func.func_type != FunctionEnum::Typedef {
    //                     args = format!("this, {}", args);
    //                 }
    //                 writeln!(
    //                     output,
    //                     "// {}\nRED4EXT_INLINE {} {}({}) {{\n    RED4ext::RelocFunc<decltype(&{})> call({}_Addr);\n    return call({});\n}}\n",
    //                     new_file_path.to_str().unwrap(),
    //                     func.return_type.name(),
    //                     symbol.name(),
    //                     header,
    //                     symbol.name(),
    //                     clean_name,
    //                     args
    //                 )?;
    //             }
    //             _ => {

    //             }
    //         }
    //     }
    // }

    Ok(())
}

// pub fn write_r4e_files<W: Write>(path: W, symbols: &[FunctionSymbol]) -> Result<()> {
//     let mut output = std::fs::File::create(path)?;
//     writeln!(output, "{}", HEADER)?;
//     for symbol in symbols {
//         writeln!(
//             output,
//             "#define {}Addr 0x{:X}",
//             symbol.name(),
//             symbol.rva()
//         )?;
//     }

//     Ok(())
// }

pub fn write_rust_header<W: Write>(mut output: W, symbols: &[FunctionSymbol]) -> Result<()> {
    writeln!(output, "{}", HEADER)?;
    for symbol in symbols {
        writeln!(
            output,
            "const {}_ADDR: usize = 0x{:X};",
            symbol.name().to_uppercase(),
            symbol.rva()
        )?;
    }

    Ok(())
}

pub fn format_name_for_idc(s: &str) -> String {
    s
    .replace("RED4ext::", "")
    .replace("::", "")
    .replace('<', "_")
    .replace('>', "")
    .replace(',', "_")
    .replace('*', "_p")
    .replace('&', "_r")
    .replace(' ', "")
    .replace('~', "__")
}

pub fn write_idc_headers<W: Write>(mut out: W, info: &TypeInfo) -> Result<()> {
    writeln!(out, "{}", HEADER)?;

    for (id, struc) in &info.structs {
        writeln!(out)?;
        writeln!(out, "// START_DECL HEADER")?;
        write!(out, "struct __cppobj {id} ")?;
        // if let Some(base) = struc.base {
        //     write!(out, ": {base} ")?;
        // }
        writeln!(out, "{{}}")?;
        writeln!(out, "// END_DECL")?;

        if struc.has_virtual_methods(info) {
            writeln!(out)?;
            writeln!(out, "// START_DECL HEADER")?;
            write!(out, "struct __cppobj {id}_vtbl ")?;
            // if let Some(base) = struc.base {
            //     write!(out, ": {base}_vtbl ")?;
            // }
            writeln!(out, "{{}}")?;
            writeln!(out, "// END_DECL")?;
        }
    }

    for id in info.unions.keys() {
        writeln!(out)?;
        writeln!(out, "// START_DECL HEADER")?;
        writeln!(out, "union {id} {{}}")?;
        writeln!(out, "// END_DECL")?;
    }
    Ok(())
}

pub fn write_idc_types<W: Write>(mut out: W, info: &TypeInfo) -> Result<()> {
    let pad = Pad(2);

    for (id, ty) in &info.enums {
        writeln!(out)?;
        writeln!(out, "// START_DECL TYPE")?;
        write!(out, "enum {id}")?;
        if let Some(underlying) = &ty.underlying_type {
            write!(out, ": {}", underlying.name())?;
        }
        writeln!(out, " {{")?;
        for m in &ty.members {
            let name = format!("{}_{}", format_name_for_idc(id.to_string().as_ref()), m.name);
            writeln!(out, "{pad}{} = {},", name, m.value)?;
        }
        writeln!(out, "}}")?;
        writeln!(out, "// END_DECL")?;
    }

    for (id, struc) in &info.structs {
        let safe_id;
        // if let Some(nice_name) = struc.nice_name {
            // safe_id = nice_name.to_string();
        // } else {
            safe_id = id.to_string();
        // } 

        // if struc.members.len() != 0 || struc.base.len() > 0 || (struc.has_direct_virtual_methods() && !struc.has_indirect_virtual_methods(info)) {
            writeln!(out)?;
            writeln!(out, "// START_DECL TYPE")?;
            // should actually handle pack pragmas in the type parsing
            if safe_id.starts_with("RED4ext::CString") {
                writeln!(out, "#pragma pack(4)")?;
            }
            write!(out, "struct ")?;
            if struc.base.len() > 0 {
                write!(out, "__cppobj ")?;
            }
            write!(out, "{id} ")?;
            if struc.base.len() > 0 {
                let base = itertools::join(&struc.base, ", ");
                write!(out, ": {base}")?;
            }
            writeln!(out, " {{")?;

            if struc.has_direct_virtual_methods() && !struc.has_indirect_virtual_methods(info) {
                writeln!(out, r#"{pad}{id}_vtbl *__vftable;"#)?;
            }

            for (i, m) in struc.members.iter().enumerate() {
                if m.is_bitfield {
                    let bit_size = struc
                        .members
                        .get(i + 1)
                        .and_then(|m| m.bit_offset)
                        .zip(m.bit_offset)
                        .map(|(a, b)| a - b)
                        .unwrap_or(1);
                    writeln!(out, "{pad}{}: {bit_size};", m.typ.name_with_id(&m.name))?;
                } else {
                    writeln!(out, "{pad}{};", m.typ.name_with_id(&m.name))?;
                }
            }
            writeln!(out, "}}")?;
            writeln!(out, "// END_DECL")?;
        // }

        if struc.rva != 0 {
            writeln!(out)?;
            writeln!(out, "// START_DECL VTABLE {}", struc.rva)?;
            writeln!(out, "{}", format_name_for_idc(safe_id.as_ref()))?;
            writeln!(out, "// END_DECL")?;
        }

        if struc.has_virtual_methods(info) && (struc.virtual_methods.len() > 0 || struc.base.len() > 0)  {
            writeln!(out)?;
            writeln!(out, "// START_DECL TYPE")?;
            write!(out, "struct ")?;
            if struc.base.len() > 0 {
                write!(out, "__cppobj ")?;
            }
            write!(out, "{safe_id}_vtbl ")?;
            if let Some(base) = struc.base.first() {
                write!(out, ": {base}_vtbl")?;
            }
            writeln!(out, " {{")?;
            for m in &struc.virtual_methods {
                let safe_name = m.name.replace("~", "__");
                if m.typ.params.is_empty() {
                    writeln!(
                        out,
                        "{pad}{} (*{})({safe_id} *__hidden this);",
                        m.typ.return_type.name(),
                        safe_name,
                    )?;
                } else {
                    writeln!(
                        out,
                        "{pad}{} (*{})({safe_id} *__hidden this, {});",
                        m.typ.return_type.name(),
                        safe_name,
                        m.typ.params.iter().map(Type::name).format(", "),
                    )?;
                }
            }
            writeln!(out, "}}")?;
            writeln!(out, "// END_DECL")?;

        }
    }

    for (id, struc) in &info.structs {
        if struc.has_virtual_methods(info) && (struc.virtual_methods.len() > 0 || struc.base.len() > 0)  && struc.rva != 0 {
            writeln!(out)?;
            writeln!(out, "// START_DECL VSTRUCT {}", struc.rva)?;
            writeln!(out, "{id}_vtbl")?;
            writeln!(out, "// END_DECL")?;
        }
    }

    for (id, en) in &info.unions {
        writeln!(out)?;
        writeln!(out, "// START_DECL TYPE")?;
        writeln!(out, "union {id} {{")?;
        for m in &en.members {
            writeln!(out, "{pad}{};", m.typ.name_with_id(&m.name))?;
        }
        writeln!(out, "}}")?;
        writeln!(out, "// END_DECL")?;
    }

    Ok(())
}

pub fn write_idc_funs<W: Write>(mut out: W, funs: &[FunctionSymbol]) -> Result<()> {
    writeln!(out)?;
    for fun in funs {
        match fun.function_type() {
            Type::Function(func) => {
                writeln!(out)?;
                writeln!(out, "// START_DECL FUNC {}", fun.rva())?;
                writeln!(
                    out,
                    r"typedef {};",
                    Type::Function(func).name_with_id(format_name_for_idc(fun.name()).as_ref())
                )?;
                writeln!(out, "// END_DECL")?;
            }
            _ => {}
        }
    }

    Ok(())
}

pub fn write_idc_vfuns<W: Write>(mut out: W, info: &TypeInfo) -> Result<()> {
    for (id, struc) in &info.structs {
        let safe_id = id.to_string();
        if struc.rva != 0 {
            let mut serial = false;
            for base in &struc.base {
                serial |= base.to_string() == "RED4ext::ISerializable";
            }
            if serial {
                writeln!(out)?;
                writeln!(out, "// START_DECL VFUNC {}", struc.rva)?;                    
                writeln!(
                    out,
                    "typedef {} {}({safe_id} *__hidden this);",
                    "RED4ext::CClass*",
                    format!("{}_GetNativeType", format_name_for_idc(safe_id.as_ref()))
                )?;
            }
            for m in &struc.overridden_virtual_methods {
                let rva = struc.rva + m.offset;
                // let rva = m.offset;
                writeln!(out)?;
                writeln!(out, "// START_DECL VFUNC {rva}")?;
                let safe_name = format!("{}_{}", format_name_for_idc(safe_id.as_ref()), format_name_for_idc(m.name.as_ref()));
                if m.typ.params.is_empty() {
                    writeln!(
                        out,
                        "typedef {} {}({safe_id} *__hidden this);",
                        m.typ.return_type.name(),
                        safe_name,
                    )?;
                } else {
                    writeln!(
                        out,
                        "typedef {} {}({safe_id} *__hidden this, {});",
                        m.typ.return_type.name(),
                        safe_name,
                        m.typ.params.iter().map(Type::name).format(", "),
                    )?;
                }
                writeln!(out, "// END_DECL")?;
            }
            for m in &struc.virtual_methods {
                let rva = struc.rva + m.offset;
                // let rva = m.offset;
                writeln!(out)?;
                writeln!(out, "// START_DECL VFUNC {rva}")?;
                let safe_name = format!("{}_{}", format_name_for_idc(safe_id.as_ref()), format_name_for_idc(m.name.as_ref()));
                if m.typ.params.is_empty() {
                    writeln!(
                        out,
                        "typedef {} {}({safe_id} *__hidden this);",
                        m.typ.return_type.name(),
                        safe_name,
                    )?;
                } else {
                    writeln!(
                        out,
                        "typedef {} {}({safe_id} *__hidden this, {});",
                        m.typ.return_type.name(),
                        safe_name,
                        m.typ.params.iter().map(Type::name).format(", "),
                    )?;
                }
                writeln!(out, "// END_DECL")?;
            }
        }
    }
    Ok(())
}

struct Pad(usize);

impl Display for Pad {
    #[inline]
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{0:1$}", ' ', self.0)
    }
}
