use std::collections::HashMap;
use std::fmt::Display;
use std::fs::File;
use std::io::Write;
use std::path::{Path, PathBuf};

use enum_as_inner::EnumAsInner;
use itertools::Itertools;
use ustr::Ustr;

use crate::error::{Result, SymbolError};
use crate::symbols::FunctionSymbol;
use crate::types::{FunctionEnum, StructId, StructType, Type, TypeInfo};

#[derive(Debug, Clone, PartialEq)]
pub struct FunctionError {
    error: SymbolError,
    addr_name: Ustr,
}

impl FunctionError {
    pub fn error(&self) -> &SymbolError {
        &self.error
    }
    pub fn addr_name(&self) -> &str {
        &self.addr_name
    }
    pub fn set_addr_name(&mut self, addr_name: Ustr) {
        self.addr_name = addr_name;
    }
    pub fn dedup(&self, number: u32) -> Self {
        let mut n = self.clone();
        n.addr_name = format!("{}_{}", self.addr_name, number).into();
        n
    }
}

#[derive(Debug, Clone, PartialEq, EnumAsInner)]
pub enum SymbolEntry {
    Found(FunctionSymbol),
    NotFound(FunctionError),
}

impl SymbolEntry {
    pub fn full_name(&self) -> &str {
        match self {
            Self::Found(func) => func.addr_name(),
            Self::NotFound(err) => err.addr_name(),
        }
    }
    pub fn rva(&self) -> u64 {
        match self {
            Self::Found(func) => func.rva(),
            Self::NotFound(_) => 0,
        }
    }
}

const HEADER: &str = "\
// This file has been generated by zoltan (https://github.com/jac3km4/zoltan)

#define ZOLTAN_STRINGISE(N) #N
#define ZOLTAN_EXPAND_THEN_STRINGISE(N) ZOLTAN_STRINGISE(N)
#define __LINE_STR__ ZOLTAN_EXPAND_THEN_STRINGISE(__LINE__)
";

pub fn format_name_for_addr(s: &str) -> String {
    // if s.context().is_empty() {
    //     s.name().replace("~", "_")
    // } else {
    //     format!("{}_{}", s.context().replace("RED4ext::", "").replace("::", ""), s.func_name().replace("~", "_"))
    // }

    let mut v: Vec<&str> = s.split("::").collect();
    let name = v[v.len() - 1].replace("~", "_");
    v.remove(v.len() - 1);
    if v.len() > 0 && v[0].eq("RED4ext") {
        v.remove(0);
    }
    let context = v.join("");
    if context.is_empty() {
        name.into()
    } else {
        format!("{}_{}", context, name)
    }
}

pub fn write_c_header<W: Write>(
    mut output: W,
    symbols: &[FunctionSymbol],
    errors: &[SymbolError],
    safe: bool,
    no_errors: bool,
) -> Result<Vec<SymbolEntry>, Box<dyn std::error::Error>> {
    writeln!(output, "{}", HEADER)?;
    let mut all_symbols: Vec<SymbolEntry> = vec![];
    symbols.into_iter().for_each(|f| {
        let mut n = f.to_owned().clone();
        n.set_addr_name(format_name_for_addr(f.full_name()).into());
        all_symbols.push(SymbolEntry::Found(n.to_owned()))
    });
    errors.into_iter().for_each(|f| {
        let fe = FunctionError {
            error: f.to_owned(),
            addr_name: format_name_for_addr(f.full_name().into()).into(),
        };
        all_symbols.push(SymbolEntry::NotFound(fe))
    });

    all_symbols.sort_by(|a, b| a.full_name().partial_cmp(b.full_name()).unwrap());
    all_symbols.dedup_by(|a, b| a.full_name().eq(b.full_name()) && a.rva() == b.rva());
    let (dedup, dups) = all_symbols.partition_dedup_by(|a, b| a.full_name().eq(b.full_name()));
    // sorted.sort_by(|a, b| a.rva().partial_cmp(&b.rva()).unwrap());
    let mut names_changed: Vec<SymbolEntry> = vec![];
    let mut names: HashMap<&str, u32> = HashMap::new();
    dups.iter().for_each(|f| match f {
        SymbolEntry::Found(symbol) => {
            if names.contains_key(symbol.addr_name()) {
                names.insert(symbol.addr_name(), names[symbol.addr_name()] + 1);
            } else {
                names.insert(symbol.addr_name(), 0);
            }
            names_changed.push(SymbolEntry::Found(
                symbol.dedup(names[symbol.addr_name()]).to_owned(),
            ));
        }
        SymbolEntry::NotFound(symbol) => {
            if names.contains_key(symbol.addr_name()) {
                names.insert(symbol.addr_name(), names[symbol.addr_name()] + 1);
            } else {
                names.insert(symbol.addr_name(), 0);
            }
            names_changed.push(SymbolEntry::NotFound(
                symbol.dedup(names[symbol.addr_name()]).to_owned(),
            ));
        }
    });
    let mut dedupped_symbols: Vec<SymbolEntry> = dedup
        .iter()
        .chain(names_changed.iter())
        .map(|e| e.to_owned())
        .collect();
    dedupped_symbols.sort_by(|a, b| a.full_name().partial_cmp(b.full_name()).unwrap());
    for entry in &dedupped_symbols {
        if safe {
            writeln!(output, "#ifndef {}_Addr", entry.full_name())?;
        }
        match entry {
            SymbolEntry::Found(symbol) => {
                // let addr_name = format_name_for_addr(symbol.full_name());
                // symbol.set_addr_name(addr_name.into());
                let addr_name = symbol.addr_name();
                writeln!(output, "#define {addr_name}_Addr 0x{:X}", symbol.rva())?;
            }
            SymbolEntry::NotFound(error) => {
                if !no_errors {
                    let addr_name = error.addr_name();
                    writeln!(
                        output,
                        "{0: <119}\\\n{1: <119}\\\n{2}",
                        format!("#define {addr_name}_Addr"),
                        format!(
                            r#"    0 _Pragma("message(__FILE__ \"(\" __LINE_STR__ \") : Warning: {addr_name}_Addr""#
                        ),
                        format!(r#"              "is 0 - Zoltan found {}\")")"#, error.error())
                    )?;
                }
            }
        }
        if safe {
            writeln!(output, "#endif")?;
        }
    }

    Ok(dedupped_symbols)
}

pub fn write_c_definition<W: Write>(
    mut output: W,
    symbols: &[FunctionSymbol],
    errors: &[SymbolError],
    _safe: bool,
) -> Result<()> {
    writeln!(output, "#pragma once")?;
    let header_objects = write_c_header(output.by_ref(), symbols, errors, true, true)?;
    writeln!(output, "\n#include <RED4ext/RED4ext.hpp>")?;
    writeln!(output, "#include <RED4ext/Relocation.hpp>")?;
    let mut sorted: Vec<FunctionSymbol> = vec![];
    header_objects.iter().for_each(|f| match f {
        SymbolEntry::Found(entry) => sorted.push(entry.to_owned()),
        _ => {}
    });
    // writeln!(output, "#ifdef RED4EXT_STATIC_LIB")?;
    // let mut sorted = symbols.to_vec();
    // sorted.sort_by(|a, b| a.name().partial_cmp(b.name()).unwrap());
    // sorted.dedup_by(|a, b| a.name().eq(b.name()) && a.rva() == b.rva());
    // sorted.sort_by(|a, b| a.rva().partial_cmp(&b.rva()).unwrap());
    // let map: HashMap<Ustr, &FunctionSymbol> = sorted.iter().filter(|s| s.file_name().is_some()).map(|s| (s.file_name().unwrap(), s)).into_iter().collect();
    let map = sorted
        .iter()
        .filter(|s| s.file_name().is_some())
        .group_by(|s| s.file_name().unwrap());
    for (file_name, _group) in map.into_iter() {
        let file_path = Path::new(file_name.as_ref());
        if let Some(_) = file_name.find("RED4ext/") {
            let prefix = file_name.rsplit_once("RED4ext/").unwrap().0;
            writeln!(
                output,
                "#include <{}>",
                file_path
                    .strip_prefix(prefix)
                    .unwrap()
                    .as_os_str()
                    .to_str()
                    .unwrap()
                    .to_string()
            )?;
        }
    }
    // writeln!(output, "#endif")?;
    writeln!(output, "")?;

    for symbol in sorted {
        if !symbol.needs_impl() {
            continue;
        }
        match symbol.function_type() {
            Type::Function(func) => {
                let args;
                let header_types;
                let header;
                let return_type = if func.func_type == FunctionEnum::Constructor {
                    "".to_owned().into()
                } else {
                    func.return_type.name()
                };
                match func.func_type {
                    FunctionEnum::Virtual => continue,
                    FunctionEnum::Method | FunctionEnum::Constructor | FunctionEnum::Destructor => {
                        header = func
                            .params
                            .iter()
                            .enumerate()
                            .filter(|(i, _f)| *i != 0)
                            .map(|(i, f)| f.name_with_id(format!("a{}", i).as_str()))
                            .join(", ");
                        header_types = func.params.iter().map(|f| f.name()).join(", ");
                        args = func
                            .params
                            .iter()
                            .enumerate()
                            .map(|(i, _f)| if i == 0 { "this".into() } else { format!("a{}", i) })
                            .join(", ");
                    }
                    FunctionEnum::Typedef => {
                        header = func
                            .params
                            .iter()
                            .enumerate()
                            .map(|(i, f)| f.name_with_id(format!("a{}", i).as_str()))
                            .join(", ");
                        header_types = func.params.iter().map(|f| f.name()).join(", ");
                        args = func
                            .params
                            .iter()
                            .enumerate()
                            .map(|(i, _f)| format!("a{}", i))
                            .join(", ");
                    }
                    FunctionEnum::Static => {
                        header = func
                            .params
                            .iter()
                            .enumerate()
                            .filter(|(i, _f)| *i != 0)
                            .map(|(i, f)| f.name_with_id(format!("a{}", i).as_str()))
                            .join(", ");
                        header_types = func
                            .params
                            .iter()
                            .enumerate()
                            .filter(|(i, _f)| *i != 0)
                            .map(|(_i, f)| f.name())
                            .join(", ");
                        args = func
                            .params
                            .iter()
                            .enumerate()
                            .filter(|(i, _f)| *i != 0)
                            .map(|(i, _f)| format!("a{}", i))
                            .join(", ");
                    }
                }
                // let func_type = format!("decltype(&{})", symbol.full_name());
                let func_type = format!("{} (*)({})", func.return_type.name(), header_types);
                let using = format!("using {}_t = {};", symbol.addr_name(), func_type);
                writeln!(
                    output,
                    "RED4EXT_INLINE {return_type} {}({header}) {{\n    {using}\n    RED4ext::RelocFunc<{}_t> call({}_Addr);\n    return call({args});\n}}\n",
                    symbol.full_name(),
                    symbol.addr_name(),
                    symbol.addr_name(),
                )?;
            }
            _ => {}
        }
    }
    // for (file_name, group) in map.into_iter() {
    //     let file_path = Path::new(file_name.as_ref());
    //     let mut new_file_path = file_path.to_path_buf();
    //     new_file_path.set_file_name(file_path.file_stem().unwrap().to_os_string().to_str().unwrap().to_owned() + "-inl-gen");
    //     new_file_path.set_extension("hpp");
    //     // let mut file = File::create(new_file_path)?;
    //     // writeln!(file, "{}", HEADER)?;
    //     for symbol in group {
    //         match symbol.function_type() {
    //             Type::Function(func) => {
    //                 let clean_name = symbol.name().replace("RED4ext::", "").replace("::", "_").replace("~", "_");
    //                 let header =  func.params.iter().enumerate().map(|(i, f)| f.name().to_string() + " a" + &i.to_string()).join(", ");
    //                 let mut args =  func.params.iter().enumerate().map(|(i, _f)| format!("a{}", i)).join(", ");
    //                 if func.func_type != FunctionEnum::Static && func.func_type != FunctionEnum::Typedef {
    //                     args = format!("this, {}", args);
    //                 }
    //                 writeln!(
    //                     output,
    //                     "// {}\nRED4EXT_INLINE {} {}({}) {{\n    RED4ext::RelocFunc<decltype(&{})> call({}_Addr);\n    return call({});\n}}\n",
    //                     new_file_path.to_str().unwrap(),
    //                     func.return_type.name(),
    //                     symbol.name(),
    //                     header,
    //                     symbol.name(),
    //                     clean_name,
    //                     args
    //                 )?;
    //             }
    //             _ => {

    //             }
    //         }
    //     }
    // }

    Ok(())
}

// pub fn write_r4e_files<W: Write>(path: W, symbols: &[FunctionSymbol]) -> Result<()> {
//     let mut output = std::fs::File::create(path)?;
//     writeln!(output, "{}", HEADER)?;
//     for symbol in symbols {
//         writeln!(
//             output,
//             "#define {}Addr 0x{:X}",
//             symbol.name(),
//             symbol.rva()
//         )?;
//     }

//     Ok(())
// }

pub fn write_rust_header<W: Write>(mut output: W, symbols: &[FunctionSymbol]) -> Result<()> {
    writeln!(output, "{}", HEADER)?;
    for symbol in symbols {
        writeln!(
            output,
            "const {}_ADDR: usize = 0x{:X};",
            symbol.name().to_uppercase(),
            symbol.rva()
        )?;
    }

    Ok(())
}

pub fn format_name_for_idc(s: &str) -> String {
    s.replace("RED4ext::", "")
        .replace("::", "")
        .replace('<', "_")
        .replace('>', "")
        .replace(',', "_")
        .replace('*', "_p")
        .replace('&', "_r")
        .replace(' ', "")
        .replace('~', "__")
}

const IDC_HEADER: &str = "\
// This file has been generated by zoltan (https://github.com/jac3km4/zoltan)
";

pub fn write_idc_headers<W: Write>(mut out: W, info: &TypeInfo) -> Result<()> {
    writeln!(out, "{}", IDC_HEADER)?;

    for (id, struc) in &info.structs {
        writeln!(out)?;
        writeln!(out, "// START_DECL HEADER")?;
        write!(out, "struct __cppobj {id} ")?;
        // if let Some(base) = struc.base {
        //     write!(out, ": {base} ")?;
        // }
        writeln!(out, "{{}}")?;
        writeln!(out, "// END_DECL")?;

        if struc.has_virtual_methods(info) {
            writeln!(out)?;
            writeln!(out, "// START_DECL HEADER")?;
            write!(out, "struct __cppobj {id}_vtbl ")?;
            // if let Some(base) = struc.base {
            //     write!(out, ": {base}_vtbl ")?;
            // }
            writeln!(out, "{{}}")?;
            writeln!(out, "// END_DECL")?;
        }
    }

    for id in info.unions.keys() {
        writeln!(out)?;
        writeln!(out, "// START_DECL HEADER")?;
        writeln!(out, "union {id} {{}}")?;
        writeln!(out, "// END_DECL")?;
    }
    Ok(())
}

pub fn write_idc_types<W: Write>(mut out: W, info: &TypeInfo) -> Result<()> {
    let pad = Pad(2);

    for (id, ty) in &info.enums {
        writeln!(out)?;
        writeln!(out, "// START_DECL TYPE")?;
        write!(out, "enum {id}")?;
        if let Some(underlying) = &ty.underlying_type {
            write!(out, ": {}", underlying.name())?;
        }
        writeln!(out, " {{")?;
        for m in &ty.members {
            let name = format!("{}_{}", format_name_for_idc(id.to_string().as_ref()), m.name);
            writeln!(out, "{pad}{} = {},", name, m.value)?;
        }
        writeln!(out, "}}")?;
        writeln!(out, "// END_DECL")?;
    }

    for (id, struc) in &info.structs {
        let safe_id;
        // if let Some(nice_name) = struc.nice_name {
        // safe_id = nice_name.to_string();
        // } else {
        safe_id = id.to_string();
        // }

        // if struc.members.len() != 0 || struc.base.len() > 0 || (struc.has_direct_virtual_methods() && !struc.has_indirect_virtual_methods(info)) {
        writeln!(out)?;
        writeln!(out, "// START_DECL TYPE")?;
        // should actually handle pack pragmas in the type parsing
        if safe_id.starts_with("RED4ext::CString") {
            writeln!(out, "#pragma pack(4)")?;
        }
        write!(out, "struct ")?;
        if struc.base.len() > 0 {
            write!(out, "__cppobj ")?;
        }
        write!(out, "{} ", id)?;
        if struc.base.len() > 0 {
            let base = itertools::join(&struc.base, ", ");
            write!(out, ": {base}")?;
        }
        writeln!(out, " {{")?;

        if struc.has_direct_virtual_methods() && !struc.has_indirect_virtual_methods(info) {
            writeln!(out, r#"{pad}{id}_vtbl *__vftable;"#)?;
        }

        for (i, m) in struc.members.iter().enumerate() {
            if m.is_bitfield {
                let bit_size = struc
                    .members
                    .get(i + 1)
                    .and_then(|m| m.bit_offset)
                    .zip(m.bit_offset)
                    .map(|(a, b)| a - b)
                    .unwrap_or(1);
                writeln!(out, "{pad}{}: {bit_size};", m.typ.name_with_id(&m.name))?;
            } else {
                writeln!(out, "{pad}{};", m.typ.name_with_id(&m.name))?;
            }
        }
        writeln!(out, "}}")?;
        writeln!(out, "// END_DECL")?;
        // }

        // if struc.rva != 0 {
        //     writeln!(out)?;
        //     writeln!(out, "// START_DECL VTABLE {}", struc.rva)?;
        //     writeln!(out, "{}", format_name_for_idc(safe_id.as_ref()))?;
        //     writeln!(out, "// END_DECL")?;
        // }

        if struc.has_virtual_methods(info) && (struc.virtual_methods.len() > 0 || struc.base.len() > 0) {
            writeln!(out)?;
            writeln!(out, "// START_DECL TYPE")?;
            write!(out, "struct ")?;
            if struc.base.len() > 0 {
                write!(out, "__cppobj ")?;
            }
            write!(out, "{safe_id}_vtbl ")?;
            if let Some(base) = struc.base.first() {
                write!(out, ": {base}_vtbl ")?;
            }
            writeln!(out, "{{")?;
            for m in &struc.virtual_methods {
                let safe_name = m.name.replace("~", "__");
                if m.typ.params.is_empty() {
                    writeln!(
                        out,
                        "{pad}{} (*{})({safe_id} *__hidden this);",
                        m.typ.return_type.name(),
                        safe_name,
                    )?;
                } else {
                    writeln!(
                        out,
                        "{pad}{} (*{})({safe_id} *__hidden this, {});",
                        m.typ.return_type.name(),
                        safe_name,
                        m.typ.params.iter().map(Type::name).format(", "),
                    )?;
                }
            }
            writeln!(out, "}}")?;
            writeln!(out, "// END_DECL")?;
        }
    }

    // for (id, struc) in &info.structs {
    //     if struc.has_virtual_methods(info)
    //         && (struc.virtual_methods.len() > 0 || struc.base.len() > 0)
    //         && struc.rva != 0
    //     {
    //         writeln!(out)?;
    //         writeln!(out, "// START_DECL VSTRUCT {}", struc.rva)?;
    //         writeln!(out, "{id}_vtbl")?;
    //         writeln!(out, "// END_DECL")?;
    //     }
    // }

    for (id, en) in &info.unions {
        writeln!(out)?;
        writeln!(out, "// START_DECL TYPE")?;
        writeln!(out, "union {id} {{")?;
        for m in &en.members {
            writeln!(out, "{pad}{};", m.typ.name_with_id(&m.name))?;
        }
        writeln!(out, "}}")?;
        writeln!(out, "// END_DECL")?;
    }

    Ok(())
}

pub fn write_idc_funs<W: Write>(mut out: W, funs: &[FunctionSymbol]) -> Result<()> {
    writeln!(out)?;
    for fun in funs {
        match fun.function_type() {
            Type::Function(func) => {
                writeln!(out)?;
                writeln!(out, "// START_DECL FUNC {}", fun.rva())?;
                writeln!(
                    out,
                    r"typedef {};",
                    Type::Function(func).name_with_id(format_name_for_idc(fun.name()).as_ref())
                )?;
                writeln!(out, "// END_DECL")?;
            }
            _ => {}
        }
    }

    Ok(())
}

pub fn write_idc_vfuns<W: Write>(mut out: W, info: &TypeInfo) -> Result<()> {
    for (id, struc) in &info.structs {
        let safe_id = id.to_string();
        if struc.rva != 0 {
            let mut serial = false;
            for base in &struc.base {
                serial |= base.to_string() == "RED4ext::ISerializable";
            }
            if serial {
                writeln!(out)?;
                writeln!(out, "// START_DECL VFUNC {}", struc.rva)?;
                writeln!(
                    out,
                    "typedef {} {}({safe_id} *__hidden this);",
                    "RED4ext::CClass*",
                    format!("{}_GetNativeType", format_name_for_idc(safe_id.as_ref()))
                )?;
            }
            for m in &struc.overridden_virtual_methods {
                let rva = struc.rva + m.offset;
                // let rva = m.offset;
                writeln!(out)?;
                writeln!(out, "// START_DECL VFUNC {rva}")?;
                let safe_name = format!(
                    "{}_{}",
                    format_name_for_idc(safe_id.as_ref()),
                    format_name_for_idc(m.name.as_ref())
                );
                if m.typ.params.is_empty() {
                    writeln!(
                        out,
                        "typedef {} {}({safe_id} *__hidden this);",
                        m.typ.return_type.name(),
                        safe_name,
                    )?;
                } else {
                    writeln!(
                        out,
                        "typedef {} {}({safe_id} *__hidden this, {});",
                        m.typ.return_type.name(),
                        safe_name,
                        m.typ.params.iter().map(Type::name).format(", "),
                    )?;
                }
                writeln!(out, "// END_DECL")?;
            }
            for m in &struc.virtual_methods {
                let rva = struc.rva + m.offset;
                // let rva = m.offset;
                writeln!(out)?;
                writeln!(out, "// START_DECL VFUNC {rva}")?;
                let safe_name = format!(
                    "{}_{}",
                    format_name_for_idc(safe_id.as_ref()),
                    format_name_for_idc(m.name.as_ref())
                );
                if m.typ.params.is_empty() {
                    writeln!(
                        out,
                        "typedef {} {}({safe_id} *__hidden this);",
                        m.typ.return_type.name(),
                        safe_name,
                    )?;
                } else {
                    writeln!(
                        out,
                        "typedef {} {}({safe_id} *__hidden this, {});",
                        m.typ.return_type.name(),
                        safe_name,
                        m.typ.params.iter().map(Type::name).format(", "),
                    )?;
                }
                writeln!(out, "// END_DECL")?;
            }
        }
    }
    Ok(())
}

pub fn write_til_types<W: Write>(mut out: W, info: &TypeInfo) -> Result<()> {
    // header
    out.write("IDATIL".as_bytes())?;

    let form: u32 = 0x12;
    out.write(&form.to_le_bytes())?;

    let flags: u32 = 0x2;
    out.write(&flags.to_le_bytes())?;

    let title = "Cyberpunk 2077 types generated by Zoltan";
    let title_len: u8 = title.len().try_into().unwrap();
    out.write(&title_len.to_le_bytes())?;
    out.write(title.as_bytes())?;

    let base = "mssdk64_win7";
    let base_len: u8 = base.len().try_into().unwrap();
    out.write(&base_len.to_le_bytes())?;
    out.write(base.as_bytes())?;

    let id: u8 = 0x0;
    out.write(&id.to_le_bytes())?;

    let cm: u8 = 0x13;
    out.write(&cm.to_le_bytes())?;

    let size_i: u8 = 0x4;
    out.write(&size_i.to_le_bytes())?;

    let size_b: u8 = 0x1;
    out.write(&size_b.to_le_bytes())?;

    let size_e: u8 = 0x4;
    out.write(&size_e.to_le_bytes())?;

    let def_align: u8 = 0x0;
    out.write(&def_align.to_le_bytes())?;

    let mut type_refs: HashMap<String, Vec<u8>> = HashMap::new();

    // syms

    let mut syms_buffer = Vec::<u8>::new();
    let mut num_syms: u32 = 0;

    for (id, ty) in &info.enums {
        let mut type_buffer = Vec::<u8>::new();
        type_buffer.write_type_stub(&Type::Enum(*id))?;
        type_refs.insert(id.to_string(), type_buffer);

        for m in &ty.members {
            let flags: u32 = 0x7FFFFFFF;
            syms_buffer.write(&flags.to_le_bytes())?;

            write!(syms_buffer, "{}::{}\0", id, &m.name)?;
            // write!(syms_buffer, "{}_{}\0", format_name_for_idc(&id.to_string()), format_name_for_idc(&m.name))?;

            let value: u32 = m.value.try_into().unwrap_or(0);
            syms_buffer.write(&value.to_le_bytes())?;

            let mut type_string = Vec::<u8>::new();
            let mut comment_string = Vec::<u8>::new();
            let mut field_string = Vec::<u8>::new();
            let mut field_comment_string = Vec::<u8>::new();

            let type_flag: u8 = 0x3D;
            type_string.write(&type_flag.to_le_bytes())?;

            let name_len: u8 = (id.to_string().len() + 1).try_into().unwrap();
            type_string.write(&name_len.to_le_bytes())?;

            write!(type_string, "{id}")?;

            syms_buffer.write(&type_string)?;
            write!(syms_buffer, "\0")?;
            syms_buffer.write(&comment_string)?;
            write!(syms_buffer, "\0")?;
            syms_buffer.write(&field_string)?;
            write!(syms_buffer, "\0")?;
            syms_buffer.write(&field_comment_string)?;
            write!(syms_buffer, "\0")?;

            write!(syms_buffer, "\0")?;

            num_syms += 1;
        }
    }

    out.write(&num_syms.to_le_bytes())?;

    let size: u32 = syms_buffer.len().try_into().unwrap();
    out.write(&size.to_le_bytes())?;

    out.write(&syms_buffer)?;

    // types

    let mut types_buffer = Vec::<u8>::new();
    let mut num_types: u32 = 0;

    for id in info.structs.keys().sorted() {
        for typ in info.structs[id]
            .members
            .iter()
            .map(|m| &m.typ)
            .chain(
                info.structs[id]
                    .virtual_methods
                    .iter()
                    .flat_map(|v| v.typ.params.iter().chain(std::iter::once(&v.typ.return_type))),
            )
            .collect::<Vec<&Type>>()
        {
            if let Some(stid) = get_struct_id_from_type(typ) {
                if !type_refs.contains_key(&stid.to_string()) && !info.structs.contains_key(stid) {
                    let mut type_buffer = Vec::<u8>::new();
                    type_buffer.write_type_stub(&Type::Struct(*stid))?;
                    type_refs.insert(stid.to_string(), type_buffer);
                }
            }
        }
    }

    for id in type_refs.keys().sorted() {
        types_buffer.write(&type_refs[id])?;
        num_types += 1;
    }

    for id in info.structs.keys().sorted() {
        num_types += types_buffer.write_type(&id, &info.structs[id])?;
    }

    out.write(&num_types.to_le_bytes())?;

    let types_size: u32 = types_buffer.len().try_into().unwrap();
    out.write(&types_size.to_le_bytes())?;

    out.write(&types_buffer)?;

    // macros

    let marcos: u64 = 0;
    out.write(&marcos.to_le_bytes())?;

    Ok(())
}

pub fn get_struct_id_from_type(typ: &Type) -> Option<&StructId> {
    match typ {
        Type::Void => None,
        Type::Bool => None,
        Type::Char(_) => None,
        Type::WChar => None,
        Type::Short(_) => None,
        Type::Int(_) => None,
        Type::Long(_) => None,
        Type::Float => None,
        Type::Double => None,
        Type::Pointer(inner_type) | Type::Reference(inner_type) => get_struct_id_from_type(std::rc::Rc::try_unwrap(inner_type.into()).unwrap()),
        Type::Array(inner_type) => get_struct_id_from_type(std::rc::Rc::try_unwrap(inner_type.into()).unwrap()),
        Type::FixedArray(inner_type, _) => get_struct_id_from_type(std::rc::Rc::try_unwrap(inner_type.into()).unwrap()),
        Type::Function(_) => None,
        Type::Union(_) => None,
        Type::Struct(id) => Some(id),
        Type::Enum(_) => None,
        Type::Constant(inner_type) => {
            get_struct_id_from_type(std::rc::Rc::try_unwrap(inner_type.into()).unwrap())
        }
    }
}

pub trait TilWriter {
    fn write_type(&mut self, id: &StructId, ty: &StructType) -> Result<u32>;
    fn write_type_stub(&mut self, id: &Type) -> Result<u32>;
    fn write_vtbl(&mut self, id: &StructId, ty: &StructType) -> Result<u32>;
    fn write_type_ref(&mut self, typ: &Type) -> Result<()>;
    fn write_p_string(&mut self, value: &str) -> Result<()>;
    fn write_complex_n(&mut self, value: usize) -> Result<()>;
}

impl<W> TilWriter for W
where
    W: Write,
{
    fn write_vtbl(self: &mut W, id: &StructId, ty: &StructType) -> Result<u32> {
        let mut types_added = 0;
        let mut type_buffer = Vec::<u8>::new();

        let flags: u32 = 0x7FFFFFFF;
        type_buffer.write(&flags.to_le_bytes())?;

        write!(type_buffer, "{id}_vtbl\0")?;

        let ordinal: u32 = 0;
        type_buffer.write(&ordinal.to_le_bytes())?;

        let mut type_string = Vec::<u8>::new();
        let mut comment_string = Vec::<u8>::new();
        let mut field_string = Vec::<u8>::new();
        let mut field_comment_string = Vec::<u8>::new();

        let type_flag: u8 = 0x0D; // struct
        type_string.write(&type_flag.to_le_bytes())?;

        let mut num_children = ty.virtual_methods.len() + ty.base.len();
        let struct_flags: usize = num_children << 3;
        type_string.write_complex_n(struct_flags)?;

        let fah_byte: u8 = 0xF1;
        type_string.write(&fah_byte.to_le_bytes())?;

        let attr_flags: usize = 0x100; // VFT
        type_string.write_complex_n(attr_flags - 1)?;

        // if num_children != 0 {
        //     let fah_byte: u8 = 0xF1;
        //     type_string.write(&fah_byte.to_le_bytes())?;

        //     let attr_flags: usize = 0x80; // __cppobj
        //     type_string.write_complex_n(attr_flags - 1)?;
        // }

        if !ty.base.is_empty() {
            for b in &ty.base {
                let type_flag: u8 = 0x3D;
                type_string.write(&type_flag.to_le_bytes())?;

                type_string.write_p_string(&(b.to_string() + "_vtbl"))?;
                field_string.write_p_string("")?;

                let fah_byte: u8 = 0xF1;
                type_string.write(&fah_byte.to_le_bytes())?;

                let attr_flags: usize = 0x20; // type inherits from
                type_string.write_complex_n(attr_flags - 1)?;
            }
        }

        for v in &ty.virtual_methods {
            field_string.write_p_string(&v.name)?;

            let type_flag: u8 = 0x0A; // pointer
            type_string.write(&type_flag.to_le_bytes())?;

            let type_flag: u8 = 0x0C; // function
            type_string.write(&type_flag.to_le_bytes())?;

            let type_flag: u8 = 0x71; // calling convention, or 0x51?
            type_string.write(&type_flag.to_le_bytes())?;

            type_string.write_type_ref(&v.typ.return_type)?;

            let arg_length = v.typ.params.len() + 1;
            type_string.write_complex_n(arg_length)?;

            let type_flag: u8 = 0xFF; // has attr
            type_string.write(&type_flag.to_le_bytes())?;

            let type_flag: u8 = 0x41; // __hidden?
            type_string.write(&type_flag.to_le_bytes())?;

            type_string.write_type_ref(&Type::Pointer(std::rc::Rc::new(Type::Struct(*id))))?;
            field_string.write_p_string("this")?;

            for p in &v.typ.params {
                type_string.write_type_ref(&p)?;
                field_string.write_p_string("")?;
            }
        }

        type_buffer.write(&type_string)?;
        write!(type_buffer, "\0")?;
        type_buffer.write(&comment_string)?;
        write!(type_buffer, "\0")?;
        type_buffer.write(&field_string)?;
        write!(type_buffer, "\0")?;
        type_buffer.write(&field_comment_string)?;
        write!(type_buffer, "\0")?;

        write!(type_buffer, "\0")?;

        types_added += 1;

        self.write(&type_buffer)?;

        Ok(types_added)
    }

    fn write_type_stub(self: &mut W, id: &Type) -> Result<u32> {
        let flags: u32 = 0x7FFFFFFF;
        self.write(&flags.to_le_bytes())?;

        write!(self, "{}\0", id.name())?;

        let ordinal: u32 = 0;
        self.write(&ordinal.to_le_bytes())?;

        let mut type_string = Vec::<u8>::new();
        let mut comment_string = Vec::<u8>::new();
        let mut field_string = Vec::<u8>::new();
        let mut field_comment_string = Vec::<u8>::new();

        let type_flag: u8 = 0x0D; // struct
        type_string.write(&type_flag.to_le_bytes())?;

        let type_flag: u8 = 0xFF;
        type_string.write(&type_flag.to_le_bytes())?;
        let type_flag: u8 = 0xFF;
        type_string.write(&type_flag.to_le_bytes())?;
        let type_flag: u8 = 0x40;
        type_string.write(&type_flag.to_le_bytes())?;

        self.write(&type_string)?;
        write!(self, "\0")?;
        self.write(&comment_string)?;
        write!(self, "\0")?;
        self.write(&field_string)?;
        write!(self, "\0")?;
        self.write(&field_comment_string)?;
        write!(self, "\0")?;

        write!(self, "\0")?;

        Ok(1)
    }

    fn write_type(self: &mut W, id: &StructId, ty: &StructType) -> Result<u32> {
        let mut types_added = 0;
        let mut type_buffer = Vec::<u8>::new();

        let flags: u32 = 0x7FFFFFFF;
        type_buffer.write(&flags.to_le_bytes())?;

        write!(type_buffer, "{id}\0")?;

        let ordinal: u32 = 0;
        type_buffer.write(&ordinal.to_le_bytes())?;

        let mut type_string = Vec::<u8>::new();
        let mut comment_string = Vec::<u8>::new();
        let mut field_string = Vec::<u8>::new();
        let mut field_comment_string = Vec::<u8>::new();

        let type_flag: u8 = 0x0D;
        type_string.write(&type_flag.to_le_bytes())?;

        let mut num_children = ty.members.len() + ty.base.len();
        if ty.has_direct_virtual_methods() && ty.base.len() == 0 {
            num_children += 1;
        }
        let struct_flags: usize = num_children << 3;
        type_string.write_complex_n(struct_flags)?;

        if ty.base.len() != 0 || ty.members.len() != 0 || ty.has_direct_virtual_methods() {
            let fah_byte: u8 = 0xF1;
            type_string.write(&fah_byte.to_le_bytes())?;

            let attr_flags: usize = 0x80; // __cppobj
            type_string.write_complex_n(attr_flags - 1)?;
        }

        if ty.base.len() != 0 {
            field_comment_string.write("\x04\x052.".as_bytes())?;
        }

        if ty.has_direct_virtual_methods() {
            types_added += self.write_vtbl(&id, &ty)?;
        }

        if !ty.base.is_empty() {
            for b in &ty.base {
                let type_flag: u8 = 0x3D;
                type_string.write(&type_flag.to_le_bytes())?;

                type_string.write_p_string(&b.to_string())?;
                field_string.write_p_string("")?;

                let fah_byte: u8 = 0xF1;
                type_string.write(&fah_byte.to_le_bytes())?;

                let attr_flags: usize = 0x20; // type inherits from
                type_string.write_complex_n(attr_flags - 1)?;

            }
        } else if ty.has_direct_virtual_methods() {
            let type_flag: u8 = 0x0A; // pointer
            type_string.write(&type_flag.to_le_bytes())?;

            let type_flag: u8 = 0x3D; // typedef
            type_string.write(&type_flag.to_le_bytes())?;

            type_string.write_p_string(&(id.to_string() + "_vtbl"))?;
            field_string.write_p_string("__vftable")?;

            let fah_byte: u8 = 0xF1;
            type_string.write(&fah_byte.to_le_bytes())?;

            let attr_flags: usize = 0x100; // vft
            type_string.write_complex_n(attr_flags - 1)?;
        }

        let mut i = 3;
        for m in &ty.members {
            type_string.write_type_ref(&m.typ)?;
            field_string.write_p_string(&m.name)?;

            let field_comment = format!("\x05{}.", i);
            field_comment_string.write_p_string(&field_comment)?;
            i += 1;
        }

        type_buffer.write(&type_string)?;
        write!(type_buffer, "\0")?;
        type_buffer.write(&comment_string)?;
        write!(type_buffer, "\0")?;
        type_buffer.write(&field_string)?;
        write!(type_buffer, "\0")?;
        type_buffer.write(&field_comment_string)?;
        write!(type_buffer, "\0")?;

        write!(type_buffer, "\0")?;

        types_added += 1;

        self.write(&type_buffer)?;

        Ok(types_added)
    }

    fn write_type_ref(self: &mut W, typ: &Type) -> Result<()> {
        match typ {
            Type::Void => {
                let type_id: u8 = 0x01;
                self.write(&type_id.to_le_bytes())?;
            }
            Type::Bool => {
                let type_id: u8 = 0x02;
                self.write(&type_id.to_le_bytes())?;
            }
            Type::Char(_) => {
                let type_id: u8 = 0x32;
                self.write(&type_id.to_le_bytes())?;
            }
            Type::WChar => {
                let type_id: u8 = 0x33;
                self.write(&type_id.to_le_bytes())?;
            }
            Type::Short(_) => {
                let type_id: u8 = 0x03;
                self.write(&type_id.to_le_bytes())?;
            }
            Type::Int(_) => {
                let type_id: u8 = 0x04;
                self.write(&type_id.to_le_bytes())?;
            }
            Type::Long(_) => {
                let type_id: u8 = 0x05;
                self.write(&type_id.to_le_bytes())?;
            }
            Type::Float => {
                let type_id: u8 = 0x09;
                self.write(&type_id.to_le_bytes())?;
            }
            Type::Double => {
                let type_id: u8 = 0x19;
                self.write(&type_id.to_le_bytes())?;
            }
            Type::Pointer(inner_type) | Type::Reference(inner_type) => {
                let type_id: u8 = 0x0A;
                self.write(&type_id.to_le_bytes())?;
                self.write_type_ref(std::rc::Rc::try_unwrap(inner_type.into()).unwrap())?;
            }
            Type::Array(inner_type) => {
                let type_id: u8 = 0x0A;
                self.write(&type_id.to_le_bytes())?;
                self.write_type_ref(std::rc::Rc::try_unwrap(inner_type.into()).unwrap())?;
            }
            Type::FixedArray(inner_type, size) => {
                let type_id: u8 = 0x1B;
                self.write(&type_id.to_le_bytes())?;
                self.write_complex_n(*size)?;
                self.write_type_ref(std::rc::Rc::try_unwrap(inner_type.into()).unwrap())?;
            }
            Type::Function(_) => {
                let type_id: u8 = 0x0C;
                self.write(&type_id.to_le_bytes())?;
            }
            Type::Union(_) | Type::Struct(_) | Type::Enum(_) => {
                let type_id: u8 = 0x3D;
                self.write(&type_id.to_le_bytes())?;
                self.write_p_string(&typ.name())?;
            }
            Type::Constant(inner_type) => {
                self.write_type_ref(std::rc::Rc::try_unwrap(inner_type.into()).unwrap())?;
            }
        };

        Ok(())
    }

    fn write_p_string(self: &mut W, value: &str) -> Result<()> {
        self.write_complex_n(value.len())?;
        self.write(value.as_bytes())?;

        Ok(())
    }

    fn write_complex_n(self: &mut W, value: usize) -> Result<()> {
        if value <= 0x7E {
            let adjusted = value + 1;
            let converted: u8 = (adjusted).try_into().unwrap();
            self.write(&converted.to_le_bytes())?;
        } else if value <= 0xFFFE {
            let adjusted = value + 1;
            let mut converted = Vec::<u8>::new();
            converted.push(((adjusted & 0x7f) | 0x80).try_into().unwrap());
            converted.push(((adjusted >> 7) & 0xFF).try_into().unwrap());
            self.write(&converted)?;
        } else {
        }

        Ok(())
    }
}

struct Pad(usize);

impl Display for Pad {
    #[inline]
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{0:1$}", ' ', self.0)
    }
}
